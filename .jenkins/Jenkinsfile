// Define the job parameters.
properties([
    parameters([
        string(name: 'drakeSha', defaultValue: 'master',
          description: 'Commit SHA or branch name. ' +
            'For pull requests, enter branch name <code>pr/1234/head</code> ' +
            'or <code>pr/1234/merge</code> for pull request #1234. ' +
            'Defaults to <code>master</code>.'),
        string(name: 'ciSha', defaultValue: 'main',
          description: 'Commit SHA or branch name. ' +
            'For pull requests, enter branch name <code>pr/1234/head</code> ' +
            'or <code>pr/1234/merge</code> for pull request #1234. ' +
            'Defaults to <code>main</code>.'),
    ])
])

// Define the main pipeline.
node(getNodeLabel()) {
  // Use a custom checkout step below, since there are
  // multiple repositories with a particular directory layout.
  skipDefaultCheckout()

  stage('test') {
    timeout(600) {
      ansiColor('xterm') {
        timestamps {
          try {
            def scmVars = null
            if (isProduction()) {
              // Ignore the branch parameters for production builds,
              // always use master/main.
              scmVars = checkout()
            }
            else {
              // Use the branch parameters, but still default to master/main.
              scmVars = checkout("${params.drakeSha}", "${params.ciSha}")
            }
            // Commented now for quick testing.
            // doBuild(scmVars)
          } finally {
            try {
              addCDashBadge()
              // Only send failure emails for production builds.
              if (isProduction()) {
                emailFailureResults()
              }
            } finally {
              cleanWorkspace()
            }
          }
        }
      }
    }
  }
}

// Returns the node label from the job name.
def getNodeLabel() {
  def pattern = ~/^((linux|mac-arm)-[a-z]+(?:-unprovisioned)?)/
  def match = "${env.JOB_NAME}" =~ pattern

  if (match.find()) {
    return match.group(1)
  }
  else {
    return null
  }
}

// Returns true if this job is continuous or nightly.
def isProduction() {
  return ("${env.JOB_NAME}".contains("continuous") ||
    "${env.JOB_NAME}".contains("nightly"))
}

// Performs the checkout step for drake and drake-ci.
// By default, uses drake/master and drake-ci/main,
// but can use any commit sha or PR number as specified
// in the parameters above.
// Within the workspace, drake is cloned into `src` and
// drake-ci is cloned into `ci`.
def checkout(String drakeSha = 'master', String ciSha = 'main') {
  def scmVars = null
  retry(4) {
    scmVars = checkout([$class: 'GitSCM',
      branches: [[name: "${drakeSha}"]],
      extensions: [[$class: 'AuthorInChangelog'],
        [$class: 'CloneOption', honorRefspec: true, noTags: true],
        [$class: 'RelativeTargetDirectory', relativeTargetDir: 'src'],
        [$class: 'LocalBranch', localBranch: 'master']],
      userRemoteConfigs: [[
        credentialsId: 'ad794d10-9bc8-4a7a-a2f3-998af802cab0',
        name: 'origin',
        refspec: '+refs/heads/master:refs/remotes/origin/master',
        url: 'git@github.com:RobotLocomotion/drake.git']]])
  }
  retry(4) {
    checkout([$class: 'GitSCM',
      branches: [[name: "${ciSha}"]],
      extensions: [[$class: 'AuthorInChangelog'],
        [$class: 'CloneOption', honorRefspec: true, noTags: true],
        [$class: 'RelativeTargetDirectory', relativeTargetDir: 'ci'],
        [$class: 'LocalBranch', localBranch: 'main']],
      userRemoteConfigs: [[
        credentialsId: 'ad794d10-9bc8-4a7a-a2f3-998af802cab0',
        name: 'origin',
        refspec: '+refs/heads/main:refs/remotes/origin/main',
        url: 'git@github.com:RobotLocomotion/drake-ci.git']]])
  }
  return scmVars
}

// Performs the main build step by calling into a drake-ci script.
def doBuild(Map scmVars) {
  withCredentials([
    sshUserPrivateKey(credentialsId: 'ad794d10-9bc8-4a7a-a2f3-998af802cab0',
      keyFileVariable: 'SSH_PRIVATE_KEY_FILE'),
    string(credentialsId: 'e21b9517-8aa7-419e-8f25-19cd42e10f68',
      variable: 'DOCKER_USERNAME'),
    file(credentialsId: '912dd413-d419-4760-b7ab-c132ab9e7c5e',
      variable: 'DOCKER_PASSWORD_FILE')
  ]) {
    withEnv(["GIT_COMMIT=${scmVars.GIT_COMMIT}"]) {
      sh "${env.WORKSPACE}/ci/ctest_driver_script_wrapper.bash"
    }
  }
}

// Sends an email to Drake developers when a build fails or is unstable.
def emailFailureResults() {
  if (fileExists('RESULT')) {
    currentBuild.result = readFile 'RESULT'
    if (currentBuild.result == 'FAILURE' || currentBuild.result == 'UNSTABLE') {
      def subject = 'Build failed in Jenkins'
      if (currentBuild.result == 'UNSTABLE') {
        subject = 'Jenkins build is unstable'
      }
      emailext (
        subject: "${subject}: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
        body: "See <${env.BUILD_URL}display/redirect?page=changes> " +
          "and <${env.BUILD_URL}changes>",
        to: '$DEFAULT_RECIPIENTS',
      )
    }
  }
}

// Provides links to the results of the build via CDash.
def addCDashBadge() {
  if (fileExists('CDASH')) {
    def cDashUrl = readFile 'CDASH'
    addBadge icon: '/userContent/cdash.png',
      link: cDashUrl, text: 'View in CDash'
    addSummary icon: '/userContent/cdash.png',
      link: cDashUrl, text: 'View in CDash'
  }
}

// Deletes the workspace and tmp directories, for use at the end of a build.
def cleanWorkspace() {
  dir("${env.WORKSPACE}") {
    deleteDir()
  }
  dir("${env.WORKSPACE}@tmp") {
    deleteDir()
  }
}

// Checks the result of the build to determine the build status.
def reportEndBuildStatus() {
  if (fileExists('RESULT')) {
    currentBuild.result = readFile 'RESULT'
    switch(currentBuild.result) {
      case 'SUCCESS':
        setBuildStatus("${env.JOB_NAME} succeeded", 'SUCCESS')
        break
      case 'FAILURE':
      case 'UNSTABLE':
        setBuildStatus("${env.JOB_NAME} failed", 'FAILURE')
        break
      case 'ERROR':
        setBuildStatus("${env.JOB_NAME} errored", 'ERROR')
        break
    }
  }
}
